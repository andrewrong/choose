# choose
用Golang实现一个能选主的库；将选主的逻辑和实现抽离出来

### 1. 需求

目前在清单系统中做了做了分布式的功能，集群中的节点会有`service_node`和`controller`的两个角色，`controller`这个角色是从集群中选择出来的，并且会承担一定的特殊的责任；如果大家比较懂`kafka`的内部结构的话，里面也存在一个角色叫做`controller`，主要是监控broker的健康度或者其他的等；我通过`mongo`来做了相关功能来实现，虽然最后的功能实现了，但是整个过程与业务的代码杂糅在一起，导致整个复杂度变高了；

我自己做的时候，问了相关的同事是否有现成的库来实现这个方面的功能，最终得到的结果是目前没有，但是他正在尝试用`consul`来进行实现；研究了他的代码发现基本上和我做的流程都很类似的，所以我自己思考是否可以设计一整套库来支持对应的这种选主需求，不管后端是依赖consul或者mongo什么等，如果有这样的框架，那整个开发过程可能会更加集中在业务逻辑上.

### 2. 行为分析

我们的场景其实有两个：

* 选主
* 选出来的主能做一些特殊的任务

#### 2.1 选主

如何进行选主呢？主要的核心点

* 何时进行选举；主要有两个参数:

    * 心跳间隔时间: 为了维持主，需要通过一定频率请求来维持租期;
    * 选举超时时间: 本质是租期有效时间；超过这个时间内就表示当前主出现了问题，需要大家来通过选举的方式来选择出对应的主

* 如何进行选主

  选主的方式比较多样；zk的方式是去抢占创建唯一的临时节点，这个过程能保证唯一性；而mongo本身是通过类`raft`的协议方式来选举出主节点. 而我是通过原子去更新`mongo`成功或者失败来表示是否抢占成功，而我同事用的是`consul`;

#### 2.2 如何抽象

* 心跳函数: `heartbeat()`
* 验证主节点是否健康的函数: `checkMasterHealth()`
  本质就是检查当前主节点的健康情况；本质上其实就是判断主节点的心跳更新时间与当前的时间进行差值之后是否操作了选举超时时间；如果超过了就触发一次选举;
* 选举函数: `elect()`
  真实选举逻辑；比如执行raft协议、写mongo或者去consul那边进行抢占等

上面这些是选主必须要有的行为；后面还会存在一些为了增加定制化的一些操作：

* 节点为主，需要做的特定的任务集合; 对于这些任务可能需要有一些参数设置：
    * `task`必须支持关闭和开启
    * 任务本身不会有`Master`来调度，只会在主从切换的时候进行关闭和停止
* 辅助功能函数:
    * 错误信息的输出；这个地方可以按照事件的模型输出，有人消费就消费，没人消费就舍弃


